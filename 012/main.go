// The sequence of triangle numbers is generated by adding the natural numbers. So
// the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten
// terms would be:
//
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//      1: 1
//      3: 1,3
//      6: 1,2,3,6
//     10: 1,2,5,10
//     15: 1,3,5,15
//     21: 1,3,7,21
//     28: 1,2,4,7,14,28
//
// We can see that 28 is the first triangle number to have over five divisors.
//
// What is the value of the first triangle number to have over five hundred divisors?

package main

import "fmt"
import "github.com/jasonmobley/euler-go/primes"

func main() {
    var index, number, divisors, maxDivisors int = 0, 0, 0, 0

    for divisors <= 500 {
        index += 1
        // n(n+1)/2 gives the nth triangular number
        number = (index * (index + 1)) / 2
        divisors = numberOfDivisors(number)
        if divisors > maxDivisors {
            maxDivisors = divisors
            fmt.Printf("Most divisible triangular number found so far: %d with %d divisors\n", number, maxDivisors)
        }
    }

    fmt.Printf("%d is triangular number #%d. It has %d divisors\n", number, index, divisors)
}

func numberOfDivisors(n int) int {
    result := 1
    var primeFactorMap map[int]int
    var primeFactorSlice []int

    primeFactorMap, primeFactorSlice = primeFactorization(n)

    for _, factor := range primeFactorSlice {
        result *= primeFactorMap[factor] + 1
    }

    return result
}

// Returns the map of distinct factors to their respective number
// of occurrences within the factorization and a slice containing
// each distinct factor once.
func primeFactorization(n int) (map[int]int, []int) {
    factorMap := make(map[int]int)
    factorSlice := make([]int, 0, 20)

    for _, p := range primesUpTo(n) {
        for n % p == 0 {
            // Increment the value in the map for this factor
            factorMap[p] += 1

            if (len(factorSlice) == 0 || factorSlice[len(factorSlice)-1] != p) {
                factorSlice = append(factorSlice, p)
            }

            // Remove the current factor to continue
            n /= p
        }
        // Bail when the number to test is less than the prime divisor
        if n < p {
            break
        }
    }

    return factorMap, factorSlice
}

var primeCache []int = make([]int, 0, 10000)
var primeSieve chan int = primes.Sieve()

func primesUpTo(limit int) []int {
    primesNeeded := 0

    for i := 0; i < len(primeCache) && primeCache[i] < limit; i++ {
        primesNeeded += 1
    }

    for len(primeCache) == 0 || primeCache[len(primeCache)-1] < limit {
        primesNeeded += 1
        primeCache = append(primeCache, <-primeSieve)
    }

    return primeCache[0:primesNeeded-1]
}
